(defun pair (y x)
  (list y x))

(defun y-of (pair)
  (first pair))

(defun x-of (pair)
  (second pair))

(defun get-distance (pair)
  (let ((y (y-of pair))
		  (x (x-of pair)))
  (sqrt (+ (* y y) (* x x)))))

(defun floor-p (value)
  (logbitp 0 value))

(defun wall-p (value)
  (not (logbitp 0 value)))

(defun transparent-p (loc)
  (let ((value (get-tile-value (y-of loc) (x-of loc))))
	 (floor-p value)))

(defun blocks-light-p (y x octant origin)
  (let ((new-y (y-of origin))
		  (new-x (x-of origin)))
	 (case octant
		((0) (incf new-x x) (decf new-y y))
		((1) (incf new-x y) (decf new-y x))
		((2) (decf new-x y) (decf new-y x))
		((3) (decf new-x x) (decf new-y y))
		((4) (decf new-x x) (incf new-y y))
		((5) (decf new-x y) (incf new-y x))
		((6) (incf new-x y) (incf new-y x))
		((7) (incf new-x x) (incf new-y y)))
	 (not (transparent-p (pair new-y new-x)))))

(defun set-visible-tile (visible-table tile)
  (setf (gethash tile visible-table) t))

(defun set-visible (visible-table y x octant origin)
  (let ((new-y (first origin))
		  (new-x (second origin)))
	 (case octant
		((0) (incf new-x x) (decf new-y y))
		((1) (incf new-x y) (decf new-y x))
		((2) (decf new-x y) (decf new-y x))
		((3) (decf new-x x) (decf new-y y))
		((4) (decf new-x x) (incf new-y y))
		((5) (decf new-x y) (incf new-y x))
		((6) (incf new-x y) (incf new-y x))
		((7) (incf new-x x) (incf new-y y)))
	 (set-visible-tile visible-table (pair new-y new-x))))

(defun slope-greater (slope y x)
  (> (* (y-of slope) x) (* (x-of slope) y)))

(defun slope-greater-or-equal (slope y x)
  (>= (* (y-of slope) x) (* (x-of slope) y)))

(defun slope-less (slope y x)
  (< (* (y-of slope) x) (* (x-of slope) y)))

(defun slope-less-or-equal (slope y x)
  (<= (* (y-of slope) x) (* (x-of slope) y)))

(defun compute-visible-tiles (visible-table octant origin max-range x-start top bottom)
  (block main-func
			(loop for x from x-start to max-range
					do (let ((top-y 0)
								(bottom-y 0)
								(was-opaque -1))
						  (if (= 1 (x-of top))
							 (setf top-y x)
							 (progn (setf top-y (floor (/ (+ (x-of top) (* (y-of top) (1- (* x 2)))) (* 2 (x-of top)))))
									  (if (blocks-light-p top-y x octant origin)
										 (if (and (slope-greater-or-equal top (1+ (* 2 top-y)) (* 2 x))
													 (not (blocks-light-p (1+ top-y) x octant origin)))
											(incf top-y))
										 (let ((ax (* 2 x)))
											(if (blocks-light-p (1+ top-y) (1+ x) octant origin)
											  (incf ax))
											(if (slope-greater top (1+ (* 2 top-y)) ax)
											  (incf top-y))))))
						  (unless (= 0 (y-of bottom))
							 (progn (setf bottom-y (floor (/ (+ (x-of bottom) (* (y-of bottom) (1- (* 2 x)))) (* 2 (x-of bottom)))))
									  (if (and (slope-greater-or-equal bottom (1+ (* 2 bottom-y)) (* 2 x))
												  (blocks-light-p bottom-y x octant origin)
												  (not (blocks-light-p (1+ bottom-y) x octant origin)))
										 (incf bottom-y))))
							 (do ((y top-y (1- y)))
								((not (>= y bottom-y)))
								(if (or (< max-range 0) (<= (get-distance (pair y x)) max-range))
								  (let* ((is-opaque (blocks-light-p y x octant origin))
											(is-visible (or is-opaque
																 (and (or (not (= y top-y))
																			 (slope-greater-or-equal top y x))
																		(or (not (= y bottom-y))
																			 (slope-less-or-equal bottom y x))))))
									 (if is-visible
										(set-visible visible-table y x octant origin))
									 (if (not (= x max-range))
										(if is-opaque
										  (progn (if (= was-opaque 0)
													  (let ((nx (* 2 x))
															  (ny (1+ (* 2 y))))
														 (if (blocks-light-p (1+ y) x octant origin)
															(decf nx))
														 (if (slope-greater top ny nx)
															(if (= y bottom-y)
															  (progn (setf bottom (pair ny nx))
																		(return))
															  (compute-visible-tiles visible-table octant origin max-range
																							 (1+ x) top (pair ny nx)))
															(if (= y bottom-y)
															  (return-from main-func)))))
													(setf was-opaque 1))
										  (progn (if (> was-opaque 0)
													  (let ((nx (* 2 x))
															  (ny (1+ (* 2 y))))
														 (if (blocks-light-p (1+ y) (1+ x) octant origin)
															(incf nx))
														 (if (slope-greater-or-equal bottom ny nx)
															(return-from main-func))
														 (setf top (pair ny nx))))
													(setf was-opaque 0)))))))
						  (if (not (= was-opaque 0))
							 (return))))))

(defun full-compute-visible-tiles (visible-table origin)
  (let ((range 50))
	 (set-visible-tile visible-table origin)
	 (loop for octant from 0 to 7
			 do (compute-visible-tiles visible-table octant origin range 1 (pair 1 1) (pair 0 1))
  )))

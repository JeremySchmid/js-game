(let ((chunk-size 256)
		(loaded-chunks-table (make-hash-table :test 'equal))
		(loaded-chunks-list nil))

  (defun get-rel-coord-and-chunk (abs-coord)
	 (floor abs-coord chunk-size))

  (defun get-chunk (abs-coord)
	 (get-rel-coord-and-chunk abs-coord))

  (defun get-rel-coord (abs-coord)
	 (mod abs-coord chunk-size))

  (defun get-chunk-coord (chunk-x)
	 (* chunk-x chunk-size))

  (defun tile-value-char (value)
	 (cond ((= value 0) "@")
			 ((= value 1) ".")
			 ((= value 2) "#")
			 (t "e")))

  (defun set-tile-value (row column value)
	 (setf (aref (get-loaded-area (get-chunk row) (get-chunk column))
					 (+ (* (get-rel-coord row) chunk-size) (get-rel-coord column)))
			 value))

  (defun get-tile-value (row column)
	 (aref (get-loaded-area (get-chunk row) (get-chunk column))
			 (+ (* (get-rel-coord row) chunk-size) (get-rel-coord column))))

  (defun set-tile-memory (row column value)
	 (setf (aref (get-loaded-area (get-chunk row) (get-chunk column))
					 (+ (* chunk-size chunk-size) (* (get-rel-coord row) chunk-size) (get-rel-coord column)))
			 value))

  (defun get-tile-memory (row column)
	 (aref (get-loaded-area (get-chunk row) (get-chunk column))
			 (+ (* chunk-size chunk-size) (* (get-rel-coord row) chunk-size) (get-rel-coord column))))

  (defun print-square (player-loc row column)
	 (princ (if (and (equal (aref player-loc 0) row)
						  (equal (aref player-loc 1) column))
				 (tile-value-char 0)
				 (tile-value-char (get-tile-value row column)))))

  (defun print-row (player-loc row x-borders)
	 (do ((column (aref x-borders 0) (1+ column))) 
		((> column (aref x-borders 1)))
		(print-square player-loc row column)))

  (defun print-area (player-loc y-borders x-borders)
	 (do ((row (aref y-borders 1) (1- row)))
		((< row (aref y-borders 0)))
		(print-row player-loc row x-borders)
		(format t "~%")))

  (defun render-map (size)
	 (print-area (agent-location (get-player))
					 (vector (- (nth 0 (agent-location (get-player))) size)
								(+ (nth 0 (agent-location (get-player))) size))
					 (vector (- (nth 1 (agent-location (get-player))) size)
								(+ (nth 1 (agent-location (get-player))) size))))

  (defun init-area (y x)
	 (let ((area (make-array (* x y 2) :element-type 'fixnum :initial-element 0)))
		area))

  (defun map-generation (y x)
	 (if (and (or (= (mod y 65) 0)
					  (= (mod x 65) 0))
				 (and (not (= (mod y 65) 33))
						(not (= (mod x 65) 33))))
		2
		1))


  (defun init-area-file (chunk-y chunk-x file-name)
	 (with-open-file (file file-name :direction :output :element-type 'fixnum)
		(let ((area-vector (init-area chunk-size chunk-size)))
		  (loop for rel-y from 0 to (- chunk-size 1)
				  do (loop for rel-x from 0 to (- chunk-size 1)
							  do (let* ((abs-y (+ (get-chunk-coord chunk-y) rel-y))
											(abs-x (+ (get-chunk-coord chunk-x) rel-x))
											(count (+ (* rel-y chunk-size) rel-x))
											(value (map-generation abs-y abs-x)))
									 (setf (aref area-vector count) value))))
		  (write-sequence area-vector file))))

  (defun area-filename (y x)
	 (let ((file-string (make-string-output-stream)))
		(format file-string "chunks/(~A,~A).map" y x)
		(get-output-stream-string file-string)))

  (defun load-area (y x)
	 (let ((file-name (area-filename y x))
			 (area-vector (make-array (* chunk-size chunk-size 2) :element-type 'fixnum))
			 (chunk (list y x)))
		(unless (probe-file file-name)
		  (init-area-file y x file-name))
		(with-open-file (file file-name :element-type 'fixnum)
		  (read-sequence area-vector file))
		(setf (gethash chunk loaded-chunks-table) area-vector)
		(push chunk loaded-chunks-list)
		(gethash chunk loaded-chunks-table)))

  (defun get-loaded-area (y x)
	 (let ((chunk (list y x)))
		(if (member chunk loaded-chunks-list :test 'equal)
		  (gethash chunk loaded-chunks-table)
		  (load-area y x))))

  (defun norm-path-to (y x)
	 (let ((path-list nil)
			 (y-progress 0)
			 (x-progress 0)
			 (y-dir (signum y))
			 (x-dir (signum x))
			 (abs-y (abs y)))
		(flet ((diagonal () (incf y-progress y-dir) (incf x-progress x-dir))
				 (straight () (incf y-progress y-dir)))
		  (push (list y-progress x-progress) path-list)
		  (unless (= abs-y 0)
			 (loop until (and (= y-progress y) (= x-progress x))
					 do (cond ((= (- x x-progress) 0) (straight))
								 ((= (- (- y y-progress) (- x x-progress)) 0) (diagonal))
								 (t (let* ((diag-left (- x x-progress))
											  (str-left (- (- y y-progress) diag-left))
											  (target-ratio (/ x (- y x))))
										(if (>= (/ diag-left str-left) target-ratio)
										  (diagonal)
										  (straight)))))
					 (push (list y-progress x-progress) path-list))))
		path-list))

  (defun straight-path-to (y-source x-source y-dest x-dest)
	 ; return a list of (y x) maptiles that have to be transparent for LOS
	 (let* ((y (- y-dest y-source))
			  (x (- x-dest x-source))
			  (major (if (>= (abs y) (abs x)) y x))
			  (minor (if (>= (abs y) (abs x)) x y))
			  (path-list (norm-path-to major minor)))
		(unless (eq major y)
		  (setf path-list (mapcar #'(lambda (element) (list (nth 1 element) (nth 0 element))) path-list)))
		(mapcar #'(lambda (element) (list (+ y-source (nth 0 element)) (+ x-source (nth 1 element)))) path-list)))

  (defun norm-step-back (y x)
	 (let* ((y-dir (signum y))
			 (x-dir (signum x))
			 (diag-left x)
			 (str-left (- y diag-left)))
		(flet ((diagonal () (list (+ y (- y-dir)) (+ x (- x-dir))))
				 (straight () (list (+ y (- y-dir)) x)))
		  (if (>= diag-left str-left)
			 (diagonal)
			 (straight)))))

  (defun one-step-back (y-source x-source y-dest x-dest)
	 (let* ((y (- y-dest y-source))
			  (x (- x-dest x-source))
			  (major (if (>= (abs y) (abs x)) y x))
			  (minor (if (>= (abs y) (abs x)) x y))
			  (step-back (norm-step-back major minor)))
		(unless (eq major y)
		  (setf step-back (funcall #'(lambda (element) (list (nth 1 element) (nth 0 element))) step-back)))
		(funcall #'(lambda (element) (list (+ y-source (nth 0 element)) (+ x-source (nth 1 element)))) step-back)))

  (defun visible-from_ (y x radius)
	 (let ((visible-squares (list (list y x)))
			 (visible-transparents (list (list y x))))
		(loop for size from 1 to (floor radius)
				do (loop for y-square from (- y size) to (+ y size)
							do (loop for x-square from 0 to (+ x size)
										do (let ((y-offset (- y y-square))
													(x-offset (- x x-square)))
											  (if (and (or (= y-offset (- size))
																(= x-offset (- size))
																(= y-offset size)
																(= x-offset size))
														  (<= (sqrt (+ (* y-offset y-offset) (* x-offset x-offset))) radius))
												 (let ((must-be-visible (one-step-back y x y-square x-square)))
													(if (member must-be-visible visible-transparents :test 'equal)
													  (progn (push (list y-square x-square) visible-squares)
																(if (floor-p (get-tile-value y-square x-square))
																  (push (list y-square x-square) visible-transparents))))))))))
		visible-squares))
  )
